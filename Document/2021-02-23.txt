-> Today's task i watch and learn from today's ADO.net videos as per schedule given by,

-> Caching dataset,
	-Caching is a technique of storing frequently used data/information in memory.
	-when the same data/information is needed next time, it could be directly retrieved from the memory instead of being generated by the application.
	-The data will not be available in the following cases:
		If its lifetime expires,
		If the application releases its memory,
		If caching does not take place for some reason.

-> What is SqlCommandBuilder,
	-SqlCommandBuilder automatically generates INSERT, UPDATE and DELETE sql statements based on the SELECT statement for a single table.
	-For the Transact-SQL statements to be generated using SqlCommandBuilder, there are 2 steps
		-Step 1. Set the "SelectCommand" property of the SqlDataAdapter object
		-Step 2. Create an instance of SqlCommandBuilder class and associate the SqlDataAdapter object created above using DataAdapter property of the SqlCommandBuilder object

-> Sqlcommandbuilder update not working,
	-Two common reasons why SqlDataAdapter.Update does not work,
		1. SqlCommandBuilder object not associated with SqlDataAdapter object. Without this association SqlCommandBuilder object does not know how to generate INSERT, UPDATE and DELETE statements.
		2. The SelectCommand that is associated with SqlDataAdapter, does not return atleast one primary key or unique column.

-> Disconnected data access,
	-ADO.NET offers two data access modes
		1. Connection oriented data access
		2. Disconnected data access
	-SqlDataAdapter and DataSet objects together provide disconnected data access.
	-A DataSet is an in-memory data store that can hold one or more tables. DataSets only hold data and do not interact with the underlying database table.
	-The DataSet object has no knowledge of the underlying Data Source. It is the SqlDataAdapter object that retrieves data from the datasource.
	-This is how it works.
		1. You create an instance of SqlDataAdapter by specifying a select command and a connection object
		2. When SqlDataAdapter.Fill() method is invoked, SqlDataAdapter opens the connection to the database, executes the select command, and the DataSet is populated with the data that is retrieved. The SqlDataAdapter automatically closes the connection.
		3. You now have data in the DataSet and there is no active connection to the database. At this point you can make any changes(insert, update, delete) to the data in the DataSet. Only the data in the DataSet is changed, the underlying database table data is not changed.
		4. To update the underlying database table, invoke SqlDataAdapter.Update() method. Make sure there is an UPDATE, DELETE and INSERT command are associated with SqlDataAdapter object when Update() method is called, otherwise there would be a runtime exception.

->  Dataset.rejectchanges and dataset.acceptchanges methods,
	-When AcceptChanges() is invoked RowState property of each DataRow changes. Added and Modified rows become Unchanged, and Deleted rows are removed.
	-When RejectChanges() is invoked RowState property of each DataRow changes. Added rows are removed. Modified and Deleted rows becomes Unchanged.
	-Both AcceptChanges() and RejectChanges() methods can be invoked at the following levels
		1. At the DataSet level - When invoked at the DataSet level, they get called automatically on each DataTable with in the DataSet, and on each DataRow within each DataTable.
		2. At the DataTable level - When invoked at the DataTable level, they get called automatically on each DataRow within each DataTable.
		3. At the DataRow level - Gets called only for the row, on which it is invoked.

-> Strongly typed datasets,
	-What are strongly typed datasets
		1. Strongly Typed Dataset is generated based on the Database Schema. 
		2. Strongly Typed Dataset derive form DataSet
		3. In a strongly typed dataset the database table columns become properties and the type associated with each column is known at design time
	-Advantage of using strongly typed datasets over untyped datasets
	-Since, in a strongly typed dataset the database table columns become properties and the type associated with each column is known at design time, 
		1. Development is much easier as we will have intellisense 
		2. Any errors related to misspelt column names can be detected at compile time, rather than at runtime

->  Load xml data into sql server table using sqlbulkcopy,
	-SqlBulkCopy class is used to bulk copy data from different data sources to SQL Server database.
	-This class is present in System.Data.SqlClient namespace. This class can be used to write data only to SQL Server tables. 
	-However, the data source is not limited to SQL Server, any data source can be used, as long as the data can be loaded to a DataTable instance or read with a IDataReader instance. 
	-From a performance standpoint, SqlBulkCopy makes it very easy and efficient to copy large amounts of data.

-> Copying data from one table to another table using SqlBulkCopy,
	-The source and destination tables may be in the same database or in different databases and these database can be on the same sql server or in different servers.

-> sqlbulkcopy notifyafter example,
	-BatchSize property - Specifies the number of rows in a batch that will be copied to the destination table. The BatchSize property is very important as the performance of data transfer depends on it. The default batch size is 1. In the example below, BatchSize is set to 10000. This means once the reader has read 10000 rows they will be sent to the database as a single batch to perform the bulk copy operation.
	-NotifyAfter property - Defines the number of rows to be processed before raising SqlRowsCopied event. In the example below, NotifyAfter property is set to 5000. This means once every 5000 rows are copied to the destination table SqlRowsCopied event is raised.
	-SqlRowsCopied event - This event is raised every time the number of rows specified by NotifyAfter property are processed. This event is useful for reporting the progress of the data transfer.

-> Transactions,
	-A Transaction ensures that either all of the database operations succeed or all of them fail. This means the job is never half done, either all of it is done or nothing is done.
->Also practice today's video from above concepts.
